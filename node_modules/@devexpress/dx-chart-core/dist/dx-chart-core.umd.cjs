/**
 * Bundle of @devexpress/dx-chart-core
 * Generated: 2023-11-06
 * Version: 4.0.6
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-scale'), require('d3-shape'), require('@devexpress/dx-core')) :
    typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-scale', 'd3-shape', '@devexpress/dx-core'], factory) :
    (global = global || self, factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXChartCore = {}), global.d3Array, global.d3Scale, global.d3Shape, global.dxCore));
}(this, (function (exports, d3Array, d3Scale, d3Shape, dxCore) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || from);
    }

    /** @internal */
    var HORIZONTAL = 'horizontal';
    /** @internal */
    var VERTICAL = 'vertical';
    /** @internal */
    var TOP = 'top';
    /** @internal */
    var BOTTOM = 'bottom';
    /** @internal */
    var LEFT = 'left';
    /** @internal */
    var RIGHT = 'right';
    /** @internal */
    var MIDDLE = 'middle';
    /** @internal */
    var END = 'end';
    /** @internal */
    var START = 'start';
    /** @internal */
    var LINEAR = 'linear';
    /** @internal */
    var BAND = 'band';
    /** @internal */
    var ARGUMENT_DOMAIN = 'argument-domain';
    /** @internal */
    var VALUE_DOMAIN = 'value-domain';
    /** @internal */
    var HOVERED = 'hovered';
    /** @internal */
    var SELECTED = 'selected';
    /** @internal */
    var DIFFERENCE = 3;

    /** @internal */
    var scaleLinear = d3Scale.scaleLinear;
    var scaleBand = function () { return d3Scale.scaleBand().paddingInner(0.3).paddingOuter(0.15); };
    /** @internal */
    var isHorizontal = function (name, rotated) { return (name === ARGUMENT_DOMAIN === !rotated); };
    // tslint:disable-next-line: ban-types
    var makeScaleHelper = function (linear, band) {
        var func = function (scale) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var choosen = 'bandwidth' in scale ? band : linear;
            return choosen.apply(void 0, __spreadArray([scale], __read(args), false));
        };
        return func;
    };
    var getLinearScaleWidth = function (_) { return 0; };
    var getBandScaleWidth = function (scale) { return scale.bandwidth(); };
    /** @internal */
    var getWidth = makeScaleHelper(getLinearScaleWidth, getBandScaleWidth);
    /** @internal */
    var getValueDomainName = function (name) { return name || VALUE_DOMAIN; };
    var floatsEqual = function (a, b) { return Math.abs(a - b) < Number.EPSILON; };
    /** @internal */
    var rangesEqual = function (r1, r2) {
        return floatsEqual(r1[0], r2[0]) && floatsEqual(r1[1], r2[1]);
    };
    var wrapLinearScale = function (scale) { return scale; };
    var wrapBandScale = function (scale) {
        var ret = function (value) { return scale(value) + scale.bandwidth() / 2; };
        Object.assign(ret, scale);
        return ret;
    };
    var wrapScale = makeScaleHelper(wrapLinearScale, wrapBandScale);
    /** @internal */
    var makeScale = function (_a, range) {
        var factory = _a.factory, domain = _a.domain;
        var scale = (factory || scaleLinear)().domain(domain).range(range);
        return wrapScale(scale);
    };
    // It is implicitly supposed that Chart can accept any d3 scale. It is wrong.
    // The followings notes show that. d3 scales are not seamlessly interchangeable themselves
    // (i.e. band scale has no "invert", continuous scale has no "bandwidth").
    // We have to use "adapters" to mitigate the differences.
    // Hence Chart can actually accept any object that matches "adapter" interface.
    // TODO: We should update reference accordingly. There might be breaking changes though.
    var scaleLinearBounds = function (scale, bounds) { return bounds.map(scale); };
    // There is an issue - when range is "inverted" values are scaled incorrectly.
    //   scaleBand().domain(['a', 'b', 'c']).range([0, 60])('b') === 20
    //   scaleBand().domain(['a', 'b', 'c']).range([60, 0])('b') === 20 (should be 40)
    var scaleBandBounds = function (scale, bounds) {
        var cleanScale = scale.copy().paddingInner(0).paddingOuter(0);
        var fullRange = scale.range();
        var sign = Math.sign(fullRange[1] - fullRange[0]);
        return sign >= 0
            ? [cleanScale(bounds[0]), cleanScale(bounds[1]) + cleanScale.bandwidth()]
            : [cleanScale(bounds[0]) + cleanScale.bandwidth(), cleanScale(bounds[1])];
    };
    var moveLinearScaleBounds = function (scale, bounds, delta) {
        var fullRange = scale.range();
        var sign = Math.sign(fullRange[1] - fullRange[0]);
        var range = scaleLinearBounds(scale, bounds);
        var r0 = range[0] + delta;
        var r1 = range[1] + delta;
        // Check if new range is outside of the left border.
        if (Math.sign(r0 - fullRange[0]) !== sign) {
            r0 = fullRange[0];
            r1 = r0 + range[1] - range[0];
        }
        // Check if new range is outside of the right border.
        if (Math.sign(fullRange[1] - r1) !== sign) {
            r1 = fullRange[1];
            r0 = r1 - range[1] + range[0];
        }
        var newBounds = [scale.invert(r0), scale.invert(r1)];
        return rangesEqual(bounds, newBounds) ? bounds : newBounds;
    };
    // This is pointer "delta" processing specific for "band" scale.
    // If pointer delta is significantly smaller than band size (0.3) then movement should be skipped
    // and current delta should be added to a next one (from a new "move" event).
    // Now there is no code that accumulates deltas.
    // In order to allow band scrolling at least somehow the following is applied - if pointer delta
    // is at least greater than 30 pixel then minimal movement is performed.
    // TODO: Make proper delta accumulation!
    var adjustBandScaleMoveStep = function (delta, step) {
        var ratio = Math.abs(delta / step);
        var sign = Math.sign(delta / step);
        if (ratio >= 0.5) {
            return sign * Math.round(ratio);
        }
        if (ratio >= 0.3) {
            return sign;
        }
        if (Math.abs(delta) > 30) {
            return sign;
        }
        return 0;
    };
    // Band case is processed separately to preserve categories count in the bounds range.
    // If common inversion mechanism is used start and end bounds cannot be inverted independently
    // because of rounding issues which may add or remove categories to the new bounds.
    var moveBandScaleBounds = function (scale, bounds, delta) {
        var domain = scale.domain();
        var fullRange = scale.range();
        var step = (fullRange[1] - fullRange[0]) / domain.length;
        var rangeStep = adjustBandScaleMoveStep(delta, step);
        if (rangeStep === 0) {
            return bounds;
        }
        var range = scaleBounds(scale, bounds);
        var range0 = Math.round((range[0] - fullRange[0]) / step);
        var range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;
        var new0 = range0 + rangeStep;
        var new1 = range1 + rangeStep;
        if (new0 < 0) {
            new0 = 0;
            new1 = new0 + range1 - range0;
        }
        if (new1 > domain.length - 1) {
            new1 = domain.length - 1;
            new0 = new1 - range1 + range0;
        }
        if (new0 === range0 || new1 === range1) {
            return bounds;
        }
        return [domain[new0], domain[new1]];
    };
    // Defines how much linear scale can be zoomed it.
    // I.e. if original scale domain has size of 1, then fully zoomed scale domain has size
    // of 1 / LINEAR_SCALE_ZOOMING_THRESHOLD.
    var LINEAR_SCALE_ZOOMING_THRESHOLD = 1000;
    var growLinearScaleBounds = function (scale, bounds, delta, anchor) {
        var fullRange = scale.range();
        var minRangeThreshold = (fullRange[1] - fullRange[0]) / LINEAR_SCALE_ZOOMING_THRESHOLD;
        var sign = Math.sign(fullRange[1] - fullRange[0]);
        var range = scaleBounds(scale, bounds);
        // If zooming in and initial range is already too small then do nothing.
        if (delta > 0 && Math.abs(range[1] - range[0]) <= Math.abs(minRangeThreshold)) {
            return bounds;
        }
        // If zooming out and initial range is already too large then do nothing.
        if (delta < 0 && Math.abs(range[1] - range[0]) >= Math.abs(fullRange[1] - fullRange[0])) {
            return bounds;
        }
        var t = Math.abs((anchor - range[0]) / (range[1] - range[0]));
        var r0 = range[0] + sign * delta * 2 * t;
        var r1 = range[1] - sign * delta * 2 * (1 - t);
        // If new range is outside of the left border then clamp it.
        if (Math.sign(r0 - fullRange[0]) !== sign) {
            r0 = fullRange[0];
        }
        // If new range is outside of the right border then clamp it.
        if (Math.sign(fullRange[1] - r1) !== sign) {
            r1 = fullRange[1];
        }
        // If new range is too small then make it no less than minimal available.
        if (Math.sign(r1 - r0) !== sign || Math.abs(r1 - r0) < Math.abs(minRangeThreshold)) {
            if (Math.abs(r0 - range[0]) < Math.abs(minRangeThreshold / 2)) {
                // Dock it to the start.
                r0 = range[0];
                r1 = r0 + minRangeThreshold;
            }
            else if (Math.abs(r1 - range[1]) < Math.abs(minRangeThreshold / 2)) {
                // Dock it to the end.
                r1 = range[1];
                r0 = r1 - minRangeThreshold;
            }
            else {
                // Dock it to the anchor.
                r0 = anchor - minRangeThreshold / 2;
                r1 = anchor + minRangeThreshold / 2;
            }
        }
        var newBounds = [scale.invert(r0), scale.invert(r1)];
        return rangesEqual(bounds, newBounds) ? bounds : newBounds;
    };
    var growBandScaleBounds = function (scale, bounds, delta, anchor) {
        var domain = scale.domain();
        var fullRange = scale.range();
        var step = (fullRange[1] - fullRange[0]) / domain.length;
        var range = scaleBounds(scale, bounds);
        var range0 = Math.round((range[0] - fullRange[0]) / step);
        var range1 = range0 + Math.round((range[1] - range[0]) / step) - 1;
        // Let it be always 1 for now.
        var rangeStep = Math.sign(delta);
        if ((rangeStep === 0) ||
            (rangeStep > 0 && range0 === range1) ||
            (rangeStep < 0 && range0 === 0 && range1 === domain.length - 1)) {
            return bounds;
        }
        var t = Math.abs((anchor - range[0]) / (range[1] - range[0]));
        var new0 = range0 + Math.round(rangeStep * 2 * t);
        var new1 = range1 - Math.round(rangeStep * 2 * (1 - t));
        if (new0 < 0) {
            new0 = 0;
        }
        if (new1 > domain.length - 1) {
            new1 = domain.length - 1;
        }
        if (new0 > new1) {
            if (t <= 0.5) {
                new1 = new0;
            }
            else {
                new0 = new1;
            }
        }
        if (new0 === range0 && new1 === range1) {
            return bounds;
        }
        return [domain[new0], domain[new1]];
    };
    var invertLinearScaleBounds = function (scale, range) {
        var fullRange = scale.range();
        var match = Math.sign(fullRange[1] - fullRange[0]) === Math.sign(range[1] - range[0]);
        return [
            scale.invert(range[match ? 0 : 1]),
            scale.invert(range[match ? 1 : 0]),
        ];
    };
    var matchPointToBand = function (domain, range, p) {
        var i = Math.floor(domain.length * (p - range[0]) / (range[1] - range[0]));
        return domain[Math.min(i, domain.length - 1)];
    };
    var invertBandScaleBounds = function (scale, range) {
        var domain = scale.domain();
        var fullRange = scale.range();
        return [
            matchPointToBand(domain, fullRange, range[0]),
            matchPointToBand(domain, fullRange, range[1]),
        ];
    };
    // Though these functions are used only in *Viewport* plugin (and so should be placed right there),
    // they reside here so that internal scale specifics (*getWidth*)
    // are encapsulated in this utility file.
    /** @internal */
    var scaleBounds = makeScaleHelper(scaleLinearBounds, scaleBandBounds);
    /** @internal */
    var moveBounds = makeScaleHelper(moveLinearScaleBounds, moveBandScaleBounds);
    // "scaleBounds" would be a better name but "scale" is already occupied.
    /** @internal */
    var growBounds = makeScaleHelper(growLinearScaleBounds, growBandScaleBounds);
    /** @internal */
    var invertBoundsRange = makeScaleHelper(invertLinearScaleBounds, invertBandScaleBounds);

    var _a;
    var makeDomain = function (_a) {
        var factory = _a.factory, modifyDomain = _a.modifyDomain;
        return ({
            domain: [],
            factory: factory,
            isDiscrete: !!(factory && isDiscrete(factory)),
            modifyDomain: modifyDomain,
        });
    };
    /** @internal */
    var defaultDomains = (_a = {},
        _a[ARGUMENT_DOMAIN] = makeDomain({}),
        _a[VALUE_DOMAIN] = makeDomain({}),
        _a);
    /** @internal */
    var addDomain = function (domains, name, options) {
        var _a;
        return (__assign(__assign({}, domains), (_a = {}, _a[name] = makeDomain(options), _a)));
    };
    var mergeContinuousDomains = function (domain, items) {
        var newDomain = d3Array.extent(__spreadArray(__spreadArray([], __read(domain), false), __read(items), false));
        return rangesEqual(newDomain, domain) ? domain : newDomain;
    };
    var mergeDiscreteDomains = function (domain, items) {
        var newDomain = Array.from(new Set(__spreadArray(__spreadArray([], __read(domain), false), __read(items), false)));
        return newDomain.length === domain.length ? domain : newDomain;
    };
    var getArgument = function (point) { return point.argument; };
    var getValue = function (point) { return point.value; };
    var guessFactory = function (points, getItem) { return (points.length && typeof getItem(points[0]) === 'string' ? scaleBand : scaleLinear); };
    var isDiscrete = function (factory) { return 'bandwidth' in factory(); };
    var updateDomainFactory = function (domain, series, getItem) {
        if (domain.factory) {
            return domain;
        }
        var factory = guessFactory(series.points, getItem);
        return __assign(__assign({}, domain), { factory: factory, isDiscrete: isDiscrete(factory) });
    };
    /** @internal */
    var updateDomainItems = function (domain, items) {
        var merge = domain.isDiscrete ? mergeDiscreteDomains : mergeContinuousDomains;
        var merged = merge(domain.domain, items);
        return merged === domain.domain ? domain : __assign(__assign({}, domain), { domain: domain.modifyDomain ? domain.modifyDomain(merged) : merged });
    };
    var getArgumentDomainItems = function (series) { return series.points.map(getArgument); };
    var getValueDomainItems = function (series) {
        var items = series.points.map(getValue);
        return series.getPointTransformer.isStartedFromZero ? __spreadArray([0], __read(items), false) : items;
    };
    var updateDomain = function (domain, series, getItem, getDomainItems) { return updateDomainItems(updateDomainFactory(domain, series, getItem), getDomainItems(series)); };
    /** @internal */
    var extendDomains = function (domains, series) {
        var argumentDomain = updateDomain(domains[ARGUMENT_DOMAIN], series, getArgument, getArgumentDomainItems);
        var valueDomainName = getValueDomainName(series.scaleName);
        var valueDomain = updateDomain(domains[valueDomainName], series, getValue, getValueDomainItems);
        var changes = {};
        if (argumentDomain !== domains[ARGUMENT_DOMAIN]) {
            changes[ARGUMENT_DOMAIN] = argumentDomain;
        }
        if (valueDomain !== domains[valueDomainName]) {
            changes[valueDomainName] = valueDomain;
        }
        return Object.keys(changes).length ? __assign(__assign({}, domains), changes) : domains;
    };
    /** @internal */
    var buildScales = function (domains, ranges) {
        var scales = {};
        Object.keys(domains).forEach(function (name) {
            scales[name] = makeScale(domains[name], ranges[name === ARGUMENT_DOMAIN ? ARGUMENT_DOMAIN : VALUE_DOMAIN]);
        });
        return scales;
    };

    var isEqual = function (_a, _b) {
        var firstWidth = _a.width, firstHeight = _a.height;
        var secondWidth = _b.width, secondHeight = _b.height;
        return firstWidth === secondWidth && firstHeight === secondHeight;
    };
    /** @internal */
    var bBoxes = function (prevBBoxes, _a) {
        var _b;
        var bBox = _a.bBox, placeholder = _a.placeholder;
        if (isEqual(prevBBoxes[placeholder] || {}, bBox))
            return prevBBoxes;
        return __assign(__assign({}, prevBBoxes), (_b = {}, _b[placeholder] = bBox, _b));
    };
    /** @internal */
    var getRanges = function (paneSize, rotated) {
        var _a;
        var horRange = [0, paneSize.width];
        var verRange = [paneSize.height, 0];
        return _a = {},
            _a[ARGUMENT_DOMAIN] = rotated ? verRange : horRange,
            _a[VALUE_DOMAIN] = rotated ? horRange : verRange,
            _a;
    };

    var _a$1, _b;
    var getTicks = function (scale, count) { return (scale.ticks ? scale.ticks(count) : scale.domain()); };
    var createTicks = function (scale, count, callback) { return (getTicks(scale, count)
        .map(function (tick, index) { return callback(scale(tick), String(index), tick); })); };
    var getFormat = function (scale, count, tickFormat) {
        if (scale.tickFormat) {
            return tickFormat ? tickFormat(scale, count) : scale.tickFormat(count);
        }
        return function (tick) { return tick; };
    };
    var rotatedPositions = (_a$1 = {},
        _a$1[LEFT] = BOTTOM,
        _a$1[RIGHT] = TOP,
        _a$1[BOTTOM] = LEFT,
        _a$1[TOP] = RIGHT,
        _a$1);
    var positionFlags = (_b = {},
        _b[LEFT] = false,
        _b[RIGHT] = false,
        _b[BOTTOM] = true,
        _b[TOP] = true,
        _b);
    /** @internal */
    var getRotatedPosition = function (position) { return rotatedPositions[position]; };
    /** @internal */
    var isValidPosition = function (position, scaleName, rotated) {
        return positionFlags[position] === isHorizontal(scaleName, rotated);
    };
    var createHorizontalOptions = function (position, tickSize, indentFromAxis) {
        // Make *position* orientation agnostic - should be START or END.
        var isStart = position === BOTTOM;
        return {
            y1: 0,
            y2: isStart ? +tickSize : -tickSize,
            yText: isStart ? +indentFromAxis : -indentFromAxis,
            dy: isStart ? '1em' : '0em',
            textAnchor: MIDDLE,
        };
    };
    var createVerticalOptions = function (position, tickSize, indentFromAxis) {
        // Make *position* orientation agnostic - should be START or END.
        var isStart = position === LEFT;
        return {
            x1: 0,
            x2: isStart ? -tickSize : +tickSize,
            xText: isStart ? -indentFromAxis : +indentFromAxis,
            dy: '0.3em',
            textAnchor: isStart ? END : START,
        };
    };
    // Constant is selected to preserve original behavior described in
    // https://github.com/d3/d3-scale#continuous_ticks.
    var DEFAULT_TICK_COUNT = 10;
    var getTickCount = function (scaleRange, paneSize) {
        var rangeToPaneRatio = Math.abs(scaleRange[0] - scaleRange[1]) / paneSize;
        return Math.round(DEFAULT_TICK_COUNT * (isFinite(rangeToPaneRatio) ? rangeToPaneRatio : 1));
    };
    var createTickFilter = function (isHor, size) { return (isHor
        ? function (tick) { return tick.x1 >= 0 && tick.x1 <= size; }
        : function (tick) { return tick.y1 >= 0 && tick.y1 <= size; }); };
    /** @internal */
    var tickCoordinatesGetter = function (_a) {
        var isHor = _a.isHor, scale = _a.scale, tickCount = _a.tickCount, tickFormat = _a.tickFormat, position = _a.position, tickSize = _a.tickSize, indentFromAxis = _a.indentFromAxis;
        var formatTick = getFormat(scale, tickCount, tickFormat);
        var options = (isHor ? createHorizontalOptions : createVerticalOptions)(position, tickSize, indentFromAxis);
        return function (coordinates, key, tick) { return (__assign({ key: key, x1: coordinates, x2: coordinates, y1: coordinates, y2: coordinates, xText: coordinates, yText: coordinates, text: formatTick(tick) }, options)); };
    };
    /** @internal */
    var gridCoordinatesGetter = function (_a) {
        var isHor = _a.isHor;
        var options = isHor ? { y1: 0 } : { x1: 0 };
        return function (coordinates, key) { return (__assign({ key: key, x1: coordinates, y1: coordinates }, options)); };
    };
    /** @internal */
    var getTickCoordinates = function (_a) {
        var scaleName = _a.scaleName, scale = _a.scale, paneSize = _a.paneSize, rotated = _a.rotated, callback = _a.callback, restProps = __rest(_a, ["scaleName", "scale", "paneSize", "rotated", "callback"]);
        var isHor = isHorizontal(scaleName, rotated);
        var tickCount = getTickCount(scale.range(), paneSize[1 - Number(isHor)]);
        var ticks = createTicks(scale, tickCount, callback(__assign({ isHor: isHor, scale: scale, tickCount: tickCount }, restProps)));
        var visibleTicks = ticks.filter(createTickFilter(isHor, paneSize[1 - Number(isHor)]));
        return {
            ticks: visibleTicks,
            sides: [Number(isHor), Number(!isHor)],
        };
    };

    var getArg = function (_a) {
        var arg = _a.arg;
        return arg;
    };
    var getVal = function (_a) {
        var val = _a.val;
        return val;
    };
    var getStartVal = function (_a) {
        var startVal = _a.startVal;
        return startVal;
    };
    /** @internal */
    var dArea = d3Shape.area()
        .x(getArg)
        .y1(getVal)
        .y0(getStartVal);
    /** @internal */
    var dRotateArea = d3Shape.area()
        .x1(getStartVal)
        .x0(getVal)
        .y(getArg);
    /** @internal */
    var dLine = d3Shape.line()
        .x(getArg)
        .y(getVal);
    /** @internal */
    var dRotateLine = d3Shape.line()
        .x(getVal)
        .y(getArg);
    /** @internal */
    var dSpline = d3Shape.line()
        .x(getArg)
        .y(getVal)
        .curve(d3Shape.curveMonotoneX);
    /** @internal */
    var dRotateSpline = d3Shape.line()
        .x(getVal)
        .y(getArg)
        .curve(d3Shape.curveMonotoneY);
    /** @internal */
    var dBar = function (arg, val, startVal, width, rotated) {
        var height = Math.abs(val - startVal);
        var minVal = Math.min(val, startVal);
        return {
            x: rotated ? minVal : arg - width / 2,
            y: rotated ? arg - width / 2 : minVal,
            width: rotated ? height : width || 2,
            height: rotated ? width || 2 : height,
        };
    };
    /** @internal */
    var getPiePointTransformer = function (_a) {
        var argumentScale = _a.argumentScale, valueScale = _a.valueScale, points = _a.points;
        var x = Math.max.apply(Math, __spreadArray([], __read(argumentScale.range()), false)) / 2;
        var y = Math.max.apply(Math, __spreadArray([], __read(valueScale.range()), false)) / 2;
        var maxRadius = Math.min(x, y);
        var pieData = d3Shape.pie().sort(null).value(function (d) { return d.value; })(points);
        return function (point) {
            var _a = pieData[point.index], startAngle = _a.startAngle, endAngle = _a.endAngle;
            return __assign(__assign({}, point), { arg: x, val: y, startAngle: startAngle, endAngle: endAngle, maxRadius: maxRadius });
        };
    };
    /** @internal */
    var getLinePointTransformer = function (_a) {
        var argumentScale = _a.argumentScale, valueScale = _a.valueScale;
        return function (point) { return (__assign(__assign({}, point), { arg: argumentScale(point.argument), val: valueScale(point.value) })); };
    };
    // Though transformations for line and scatter are the same,
    // separate function instance is required as it contains additional static fields.
    /** @internal */
    var getScatterPointTransformer = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return getLinePointTransformer.apply(void 0, __spreadArray([], __read(args), false));
    };
    /** @internal */
    var getAreaPointTransformer = function (series) {
        var transform = getLinePointTransformer(series);
        var startVal = series.valueScale(0);
        return function (point) {
            var ret = transform(point);
            return __assign(__assign({}, ret), { startVal: startVal });
        };
    };
    // Used for domain calculation and stacking.
    getAreaPointTransformer.isStartedFromZero = true;
    /** @internal */
    var getBarPointTransformer = function (_a) {
        var argumentScale = _a.argumentScale, valueScale = _a.valueScale;
        var startVal = valueScale(0);
        return function (point) { return (__assign(__assign({}, point), { arg: argumentScale(point.argument), val: valueScale(point.value), startVal: startVal, maxBarWidth: getWidth(argumentScale) })); };
    };
    // Used for domain calculation and stacking.
    getBarPointTransformer.isStartedFromZero = true;
    // Used for Bar grouping.
    getBarPointTransformer.isBroad = true;
    getPiePointTransformer.getPointColor = function (palette, index) { return palette[index % palette.length]; };
    /** @internal */
    var findSeriesByName = function (name, series) { return series.find(function (seriesItem) { return seriesItem.symbolName === name; }); };
    /** @internal */
    var dSymbol = function (_a) {
        var size = _a.size;
        return d3Shape.symbol().size(Math.pow(size, 2)).type(d3Shape.symbolCircle)();
    };
    /** @internal */
    var dPie = function (maxRadius, innerRadius, outerRadius, startAngle, endAngle) { return d3Shape.arc()({
        startAngle: startAngle,
        endAngle: endAngle,
        innerRadius: innerRadius * maxRadius,
        outerRadius: outerRadius * maxRadius,
    }); };
    var getRect = function (cArg, cVal, dArg, dVal, rotated) {
        var minArg = cArg - dArg;
        var minVal = cVal - dVal;
        var maxArg = cArg + dArg;
        var maxVal = cVal + dVal;
        return rotated ? [minVal, minArg, maxVal, maxArg] : [minArg, minVal, maxArg, maxVal];
    };
    getBarPointTransformer.getTargetElement = function (point) {
        var _a = point, arg = _a.arg, val = _a.val, startVal = _a.startVal, barWidth = _a.barWidth, maxBarWidth = _a.maxBarWidth, rotated = _a.rotated;
        var halfWidth = barWidth * maxBarWidth / 2;
        var halfHeight = Math.abs(startVal - val) / 2;
        var centerVal = (val + startVal) / 2;
        return getRect(arg, centerVal, halfWidth, halfHeight, rotated);
    };
    getPiePointTransformer.getTargetElement = function (point) {
        var _a = point, x = _a.arg, y = _a.val, innerRadius = _a.innerRadius, outerRadius = _a.outerRadius, maxRadius = _a.maxRadius, startAngle = _a.startAngle, endAngle = _a.endAngle;
        var center = d3Shape.arc().centroid({
            startAngle: startAngle,
            endAngle: endAngle,
            innerRadius: innerRadius * maxRadius,
            outerRadius: outerRadius * maxRadius,
        });
        var cx = center[0] + x;
        var cy = center[1] + y;
        return getRect(cx, cy, 0.5, 0.5, false);
    };
    getAreaPointTransformer.getTargetElement = function (_a) {
        var arg = _a.arg, val = _a.val, rotated = _a.rotated;
        return (getRect(arg, val, 1, 1, rotated));
    };
    getLinePointTransformer.getTargetElement = getAreaPointTransformer.getTargetElement;
    getScatterPointTransformer.getTargetElement = function (obj) {
        var _a = obj, arg = _a.arg, val = _a.val, point = _a.point, rotated = _a.rotated;
        var t = point.size / 2;
        return getRect(arg, val, t, t, rotated);
    };
    var getUniqueName = function (list, name) {
        var names = new Set(list.map(function (item) { return item.name; }));
        var ret = name;
        while (names.has(ret)) {
            // @ts-ignore
            ret = ret.replace(/\d*$/, function (str) { return (str ? +str + 1 : 0); });
        }
        return ret;
    };
    // TODO: Memoization is much needed here.
    // Though "series" list never persists, single "series" item most often does.
    var createPoints = function (_a, data, props, palette) {
        var argumentField = _a.argumentField, valueField = _a.valueField, getPointTransformer = _a.getPointTransformer;
        var points = [];
        data.forEach(function (dataItem, index) {
            var argument = dataItem[argumentField];
            var value = dataItem[valueField];
            if (argument !== undefined && value !== undefined) {
                points.push(__assign(__assign({ argument: argument, value: value, index: index }, props), { color: getPointTransformer.getPointColor
                        ? getPointTransformer.getPointColor(palette, index) : props.color }));
            }
        });
        return points;
    };
    /** @internal */
    var addSeries = function (series, data, palette, props, restProps) {
        // It is used to generate unique series dependent attribute names for patterns.
        // *symbolName* cannot be used as it cannot be part of DOM attribute name.
        var index = series.length;
        var seriesColor = props.color || palette[index % palette.length];
        return __spreadArray(__spreadArray([], __read(series), false), [__assign(__assign({}, props), { index: index, name: getUniqueName(series, props.name), points: createPoints(props, data, __assign(__assign({}, restProps), { color: seriesColor }), palette), color: seriesColor })], false);
    };
    // TODO: Memoization is much needed here by the same reason as in "createPoints".
    // Make "scales" persistent first.
    var scalePoints = function (series, scales, rotated) {
        var transform = series.getPointTransformer(__assign(__assign({}, series), { argumentScale: scales[ARGUMENT_DOMAIN], valueScale: scales[getValueDomainName(series.scaleName)] }));
        var ret = __assign(__assign({}, series), { rotated: rotated, points: series.points.map(function (point) { return (__assign(__assign({}, transform(point)), { rotated: rotated })); }) });
        return ret;
    };
    /** @internal */
    var scaleSeriesPoints = function (series, scales, rotated) { return series.map(function (seriesItem) { return scalePoints(seriesItem, scales, rotated); }); };
    /** @internal */
    var getVisibility = function (pane, centerX, centerY, width, height) {
        return (centerX - width / 2 < 0 && centerX + width / 2 < 0)
            || (centerX - width / 2 > pane.width && centerX + width / 2 > pane.width)
            || (centerY - height / 2 < 0 && centerY + height / 2 < 0)
            || (centerY - height / 2 > pane.height && centerY + height / 2 > pane.height) ?
            'hidden' : 'visible';
    };
    /** @internal */
    var adjustBarSize = function (bar, _a) {
        var width = _a.width, height = _a.height;
        var x = Math.max(0, bar.x);
        var y = Math.max(0, bar.y);
        return {
            x: x,
            y: y,
            width: Math.min(width, bar.x + bar.width) - x,
            height: Math.min(height, bar.y + bar.height) - y,
        };
    };
    /** @internal */
    var isValuesChanged = function (previous, current) {
        return Object.entries(previous).some(function (el) { return el[1] !== current[el[0]]; });
    };
    /** @internal */
    var isCoordinatesChanged = function (_a, _b) {
        var prevCoordinates = _a.coordinates;
        var coordinates = _b.coordinates;
        if (prevCoordinates.length !== coordinates.length) {
            return true;
        }
        return prevCoordinates.some(function (el, index) {
            return el.arg !== coordinates[index].arg || el.val !== coordinates[index].val;
        });
    };
    /** @internal */
    var isScalesChanged = function (previous, current) {
        return !rangesEqual(previous.argScale.range(), current.argScale.range()) ||
            !rangesEqual(previous.valScale.range(), current.valScale.range());
    };

    // "Stack" plugin relies on "data" and "series" getters and
    // knowledge about "getPointTransformer" and "path" functions behavior.
    var buildSeriesToStackMap = function (stacks) {
        var result = {};
        stacks.forEach(function (_a, i) {
            var series = _a.series;
            series.forEach(function (name) {
                result[name] = i;
            });
        });
        return result;
    };
    var getStackedPointTransformer = function (getPointTransformer) {
        var wrapper = function (series) {
            var transform = getPointTransformer(series);
            var valueScale = series.valueScale;
            return function (point) {
                var ret = transform(point);
                return __assign(__assign({}, ret), { startVal: valueScale(point.value0) });
            };
        };
        // Preserve static fields of original transformer.
        Object.assign(wrapper, getPointTransformer);
        return wrapper;
    };
    var collectStacks = function (seriesList, seriesToStackMap, stacksKeys, seriesPositions) {
        seriesList.forEach(function (_a) {
            var name = _a.name, valueField = _a.valueField;
            var stackId = seriesToStackMap[name];
            if (stackId === undefined) {
                return;
            }
            if (!stacksKeys[stackId]) {
                stacksKeys[stackId] = [];
            }
            seriesPositions[name] = stacksKeys[stackId].length;
            stacksKeys[stackId].push(valueField);
        });
        // Stack cannot consist of single series.
        Object.keys(stacksKeys).forEach(function (stackId) {
            if (stacksKeys[stackId].length === 1) {
                delete stacksKeys[stackId];
            }
        });
    };
    var getStackedData = function (stacksKeys, dataItems, offset, order) {
        var result = {};
        Object.keys(stacksKeys).forEach(function (stackId) {
            result[stackId] = d3Shape.stack().keys(stacksKeys[stackId])
                .order(order)
                .offset(offset)(dataItems);
        });
        return result;
    };
    var buildStackedSeries = function (series, dataItems) {
        var points = series.points.map(function (point) {
            var _a = __read(dataItems[point.index], 2), value0 = _a[0], value = _a[1];
            return __assign(__assign({}, point), { value: value, value0: value0 });
        });
        var stackedSeries = __assign(__assign({}, series), { points: points, isStacked: true });
        if (series.getPointTransformer.isStartedFromZero) {
            stackedSeries.getPointTransformer = getStackedPointTransformer(series.getPointTransformer);
        }
        return stackedSeries;
    };
    var applyStacking = function (seriesList, dataItems, seriesToStackMap, offset, order) {
        var stacksKeys = {};
        var seriesPositions = {};
        collectStacks(seriesList, seriesToStackMap, stacksKeys, seriesPositions);
        if (Object.keys(stacksKeys).length === 0) {
            return seriesList;
        }
        var stackedData = getStackedData(stacksKeys, dataItems, offset, order);
        return seriesList.map(function (seriesItem) {
            var stackId = seriesToStackMap[seriesItem.name];
            var stackData = stackedData[stackId];
            if (!stackData) {
                return seriesItem;
            }
            var position = seriesPositions[seriesItem.name];
            return buildStackedSeries(seriesItem, stackData[position]);
        });
    };
    var getGroupName = function (series, i, seriesToStackMap) {
        var stackId = seriesToStackMap[series.name];
        return stackId >= 0 ? String(stackId) : "group-".concat(i);
    };
    var getGroupedPointTransformer = function (getPointTransformer, groupCount, groupOffset) {
        var wrapper = function (series) {
            var transform = getPointTransformer(series);
            var widthCoeff = 1 / groupCount;
            return function (point) {
                var original = transform(point);
                var arg = (original.arg - original.maxBarWidth * (0.5 - 0.5 * widthCoeff - groupOffset * widthCoeff));
                var result = __assign(__assign({}, original), { arg: arg, maxBarWidth: original.maxBarWidth / groupCount });
                return result;
            };
        };
        // Preserve static fields of original transformer.
        Object.assign(wrapper, getPointTransformer);
        return wrapper;
    };
    var applyGrouping = function (seriesList, seriesToStackMap) {
        var groups = new Set();
        seriesList.forEach(function (seriesItem, i) {
            if (seriesItem.getPointTransformer.isBroad) {
                groups.add(getGroupName(seriesItem, i, seriesToStackMap));
            }
        });
        // There cannot be single group.
        if (groups.size < 2) {
            return seriesList;
        }
        var scale = d3Scale.scaleBand().domain(Array.from(groups)).range([0, groups.size]);
        return seriesList.map(function (seriesItem, i) {
            if (!seriesItem.getPointTransformer.isBroad) {
                return seriesItem;
            }
            var getPointTransformer = getGroupedPointTransformer(seriesItem.getPointTransformer, groups.size, scale(getGroupName(seriesItem, i, seriesToStackMap)));
            return __assign(__assign({}, seriesItem), { getPointTransformer: getPointTransformer });
        });
    };
    /** @internal */
    var getStackedSeries = function (seriesList, dataItems, _a) {
        var stacks = _a.stacks, offset = _a.offset, order = _a.order;
        var map = buildSeriesToStackMap(stacks);
        var stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);
        var groupedSeriesList = applyGrouping(stackedSeriesList, map);
        return groupedSeriesList;
    };
    var resetDomainItems = function (domains) {
        var result = {};
        Object.keys(domains).forEach(function (key) {
            result[key] = __assign(__assign({}, domains[key]), { domain: [] });
        });
        return result;
    };
    var extendDomainsWithAdditionalItems = function (domains, series) {
        var _a;
        var items = series.points.map(function (point) { return point.value0; });
        var key = getValueDomainName(series.scaleName);
        var domain = updateDomainItems(domains[key], items);
        return domain !== domains[key] ? __assign(__assign({}, domains), (_a = {}, _a[key] = domain, _a)) : domains;
    };
    // Stacking changes data - so computed domains have to be discarded
    // and recalculated from the new stacked data.
    /** @internal */
    var getStackedDomains = function (domains, seriesList) {
        var stackedSeries = seriesList.filter(function (series) { return series.isStacked; });
        if (!stackedSeries.length) {
            return domains;
        }
        // Recalculate domains in a common way.
        var rebuiltDomains = seriesList.reduce(extendDomains, resetDomainItems(domains));
        // Take additional "value0" fields into account.
        return stackedSeries.reduce(extendDomainsWithAdditionalItems, rebuiltDomains);
    };

    /** @internal */
    var easeOutCubic = function (t) { return (t - 1) * (t - 1) * (t - 1) + 1; };
    /** @internal */
    var getDelay = function (index, isStart) { return isStart ? index * 30 : 0; };
    /** @internal */
    var getStartVal$1 = function (scales) {
        return scales.valScale.copy().clamp(true)(0);
    };
    /** @internal */
    var getPathStart = function (scales, _a) {
        var coordinates = _a.coordinates;
        var start = getStartVal$1(scales);
        return { coordinates: coordinates.map(function (coord) {
                return ({ arg: coord.arg, val: start, startVal: start });
            }) };
    };
    /** @internal */
    var getPointStart = function (scales, _a) {
        var arg = _a.arg;
        var start = getStartVal$1(scales);
        return { arg: arg, val: start, startVal: start };
    };
    /** @internal */
    var getPieStart = function (scales, _a) {
        var startAngle = _a.startAngle, endAngle = _a.endAngle;
        return ({ innerRadius: 0, outerRadius: 0, startAngle: startAngle, endAngle: endAngle });
    };

    // Comparing by reference is not an option as Tracker always sends new objects.
    // Tracker cannot persist references as it actually operates with simple scalars
    // and constructs objects to provide info in a slightly more suitable way.
    var compareTargets = function (target1, target2) { return (target1.series === target2.series && target1.point === target2.point); };
    // If *currentTarget* is among *targets* then it has priority but only while its distance
    // is not significantly greater (DISTANCE_PRIORITY_RATIO) than that of the best candidate.
    var selectTarget = function (targets, currentTarget) {
        var candidate = targets[0];
        if (!currentTarget) {
            return candidate;
        }
        if (!candidate) {
            return null;
        }
        return compareTargets(candidate, currentTarget) ? undefined : candidate;
    };
    /** @internal */
    var processPointerMove = function (targets, currentTarget, notify) {
        var nextTarget = selectTarget(targets, currentTarget);
        if (nextTarget === undefined) {
            return undefined;
        }
        if (notify) {
            notify(nextTarget);
        }
        return nextTarget;
    };

    // This function is to be called from context where DOM is available -
    // so *window* can be accessed safely.
    /** @internal */
    var getOffset = function (element) {
        var _a = element.getBoundingClientRect(), left = _a.left, top = _a.top;
        // Safer way to get window.
        var defaultView = element.ownerDocument.defaultView;
        var _b = defaultView, pageXOffset = _b.pageXOffset, pageYOffset = _b.pageYOffset;
        return [left + pageXOffset, top + pageYOffset];
    };
    /** @internal */
    var getEventCoords = function (e, offset) {
        var _a = e.touches ? e.touches[0] : e, pageX = _a.pageX, pageY = _a.pageY;
        return [pageX - offset[0], pageY - offset[1]];
    };

    /** @internal */
    var getParameters = function (series, target) {
        var currentSeries = series.find(function (_a) {
            var name = _a.name;
            return target.series === name;
        });
        var item = currentSeries.points.find(function (point) { return point.index === target.point; });
        return {
            element: currentSeries.getPointTransformer.getTargetElement(item),
            text: "".concat(item.value),
        };
    };
    /** @internal */
    var createReference = function (rect, rootRef) { return ({
        // These two fields together with *width* and *height* are left with stub data for
        // simplicity reasons - they seem to be unused by *Popper*.
        clientWidth: 0,
        clientHeight: 0,
        getBoundingClientRect: function () {
            // This function is expected to be called (by the *Popper*) when DOM is ready -
            // so *rootRef.current* can be accessed.
            var offset = getOffset(rootRef.current);
            // *getBoundingClientRect* of a real html element is affected by window scrolling.
            // *popper.js* subscribes "html -> getBoundingClientRect -> (left, top)" from
            // "reference -> getBoundingClientRect" - so here it is added.
            var htmlRect = rootRef.current.ownerDocument.documentElement.getBoundingClientRect();
            var left = rect[0] + offset[0] + htmlRect.left;
            var right = rect[2] + offset[0] + htmlRect.left;
            var top = rect[1] + offset[1] + htmlRect.top;
            var bottom = rect[3] + offset[1] + htmlRect.top;
            return {
                left: left,
                top: top,
                right: right,
                bottom: bottom,
                width: right - left,
                height: bottom - top,
            };
        },
    }); };
    /** @internal */
    var processHandleTooltip = function (targets, currentTarget, onTargetItemChange) {
        var filterTargets = targets.filter(function (target) { return target.point !== undefined; });
        return processPointerMove(filterTargets, currentTarget, onTargetItemChange);
    };

    var getArgumentBounds = function (viewport) { return (viewport && viewport.argumentStart !== undefined && viewport.argumentEnd !== undefined
        ? [viewport.argumentStart, viewport.argumentEnd] : null); };
    var getValueBounds = function (viewport) { return (viewport && viewport.valueStart !== undefined && viewport.valueEnd !== undefined
        ? [viewport.valueStart, viewport.valueEnd] : null); };
    var getValueScaleName = function (viewport) { return (getValueDomainName(viewport && viewport.scaleName)); };
    var getDefaultBounds = function (scale) {
        var domain = scale.domain();
        return [domain[0], domain[domain.length - 1]];
    };
    var proportionallyExtendRange = function (range, subRange) {
        var p = (subRange[0] - subRange[1]) / (range[0] - range[1]);
        var q = subRange[0] - p * range[0];
        return [
            (range[0] - q) / p,
            (range[1] - q) / p,
        ];
    };
    var adjustRange = function (domain, bounds, range) {
        var scale = makeScale(domain, range);
        var subRange = scaleBounds(scale, bounds);
        return rangesEqual(subRange, range) ? range : proportionallyExtendRange(range, subRange);
    };
    var update = function (ranges, changes, key, domain, bounds) {
        var newRange = adjustRange(domain, bounds, ranges[key]);
        if (newRange !== ranges[key]) {
            changes[key] = newRange;
        }
    };
    /** @internal */
    var adjustLayout = function (domains, ranges, viewport) {
        var changes = {};
        var argumentBounds = getArgumentBounds(viewport);
        if (argumentBounds) {
            update(ranges, changes, ARGUMENT_DOMAIN, domains[ARGUMENT_DOMAIN], argumentBounds);
        }
        var valueBounds = getValueBounds(viewport);
        if (valueBounds) {
            update(ranges, changes, VALUE_DOMAIN, domains[getValueScaleName(viewport)], valueBounds);
        }
        return Object.keys(changes).length ? __assign(__assign({}, ranges), changes) : ranges;
    };
    var boundsForScale = function (name, scales, currentBounds, interaction, type, delta, anchor, range) {
        if (!checkInteraction(interaction, type)) {
            return null;
        }
        var scale = scales[name];
        var bounds = currentBounds || getDefaultBounds(scale);
        var newBounds;
        if (type === 'pan') {
            newBounds = moveBounds(scale, bounds, delta);
        }
        else if (type === 'zoom') {
            newBounds = range ? invertBoundsRange(scale, range) : growBounds(scale, bounds, delta, anchor);
        }
        return newBounds !== bounds ? newBounds : null;
    };
    /** @internal */
    var getViewport = function (scales, rotated, _a, type, deltas, anchors, ranges, viewport, onViewportChange) {
        var _b = __read(_a, 2), argInteraction = _b[0], valInteraction = _b[1];
        var argIndex = Number(rotated);
        var valIndex = 1 - argIndex;
        var changes = {};
        var argumentBounds = boundsForScale(ARGUMENT_DOMAIN, scales, getArgumentBounds(viewport), argInteraction, type, deltas ? deltas[argIndex] : 0, anchors ? anchors[argIndex] : 0, ranges ? ranges[argIndex] : undefined);
        var valueBounds = boundsForScale(getValueScaleName(viewport), scales, getValueBounds(viewport), valInteraction, type, deltas ? deltas[valIndex] : 0, anchors ? anchors[valIndex] : 0, ranges ? ranges[valIndex] : undefined);
        if (argumentBounds) {
            changes.argumentStart = argumentBounds[0];
            changes.argumentEnd = argumentBounds[1];
        }
        if (valueBounds) {
            changes.valueStart = valueBounds[0];
            changes.valueEnd = valueBounds[1];
        }
        if (Object.keys(changes).length) {
            var newViewport = __assign(__assign({}, viewport), changes);
            if (onViewportChange) {
                onViewportChange(newViewport);
            }
            return { viewport: newViewport };
        }
        return null;
    };
    /** @internal */
    var getDeltaForTouches = function (touches) {
        var deltaX = touches[0].pageX - touches[1].pageX;
        var deltaY = touches[0].pageY - touches[1].pageY;
        var delta = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        var center = [
            (touches[0].pageX + touches[1].pageX) / 2,
            (touches[0].pageY + touches[1].pageY) / 2,
        ];
        return { delta: delta, center: center };
    };
    /** @internal */
    var isKeyPressed = function (event, key) { return event["".concat(key, "Key")]; };
    /** @internal */
    var getWheelDelta = function (_a) {
        var wheelDelta = _a.wheelDelta, deltaY = _a.deltaY;
        return wheelDelta !== undefined ? wheelDelta : deltaY * -30; // deltaY for FF
    };
    /** @internal */
    var isMultiTouch = function (e) { return e.touches && e.touches.length === 2; };
    /** @internal */
    var attachEvents = function (node, handlers) {
        Object.keys(handlers).forEach(function (el) {
            node.addEventListener(el, handlers[el], { passive: false });
        });
    };
    /** @internal */
    var detachEvents = function (node, handlers) {
        Object.keys(handlers).forEach(function (el) {
            node.removeEventListener(el, handlers[el]);
        });
    };
    /** @internal */
    var getRect$1 = function (rotated, interactionWithArguments, interactionWithValues, initial, current, pane) {
        var isZoomArgument = checkInteraction(interactionWithArguments, 'zoom');
        var isZoomValue = checkInteraction(interactionWithValues, 'zoom');
        var isXFixed = rotated ? isZoomValue : isZoomArgument;
        var isYFixed = rotated ? isZoomArgument : isZoomValue;
        var x = isXFixed ? Math.min(initial[0], current[0]) : 0;
        var width = isXFixed ? Math.abs(initial[0] - current[0]) : pane.width;
        var y = isYFixed ? Math.min(initial[1], current[1]) : 0;
        var height = isYFixed ? Math.abs(initial[1] - current[1]) : pane.height;
        return {
            x: x,
            y: y,
            width: width,
            height: height,
        };
    };
    var checkInteraction = function (interaction, type) {
        return interaction === 'both' || interaction === type;
    };
    /** @internal */
    var setCursorType = function (node, type) {
        var defaultType = 'pointer';
        node.style.cursor = type ? type : defaultType;
    };

    /** @internal */
    var isReadyToRenderSeries = function (_a, _b, isPreviousDataEmpty, axesExist) {
        var pane = _a.pane, restLayouts = __rest(_a, ["pane"]);
        var current = _b.current;
        if (!pane.width && !pane.height) {
            return false;
        }
        var bbox = { width: current.clientWidth, height: current.clientHeight };
        var width = pane.width;
        var height = pane.height;
        Object.entries(restLayouts).forEach(function (el) {
            var orientation = el[0].split('-')[0];
            if (orientation === 'top' || orientation === 'bottom') {
                height += el[1].height;
            }
            else {
                width += el[1].width;
            }
        });
        return Math.abs(bbox.width - width) < DIFFERENCE &&
            Math.abs(bbox.height - height) < DIFFERENCE
            && isPreviousDataEmptyOrNoAxes(isPreviousDataEmpty, axesExist);
    };
    var isPreviousDataEmptyOrNoAxes = function (isPreviousDataEmpty, axesExist) { return !isPreviousDataEmpty || !axesExist; };

    var getSegmentLength = function (dx, dy) { return Math.sqrt(dx * dx + dy * dy); };
    // *distance* is a normalized distance to point.
    // It belongs to [0, Infinity):
    //  = 0 - at point center
    //  = 1 - at point border
    //  > 1 - outside point
    // This function is called from event handlers (when DOM is available) -
    // *window.document* can be accessed safely.
    var createContext = function () { return document.createElement('canvas').getContext('2d'); };
    // For a start using browser canvas will suffice.
    // However a better and more clean solution should be found.
    // Can't d3 perform hit testing?
    var createCanvasAbusingHitTester = function (makePath, points, rotated) {
        var ctx = createContext();
        var path = makePath(rotated);
        path.context(ctx);
        path(points);
        return function (_a) {
            var _b = __read(_a, 2), x = _b[0], y = _b[1];
            return ctx.isPointInPath(x, y);
        };
    };
    var LINE_POINT_SIZE = 20;
    var LINE_TOLERANCE = 10;
    var getDistance = function (_a, _b, rotated) {
        var _c = __read(_a, 2), px = _c[0], py = _c[1];
        var arg = _b.arg, val = _b.val;
        var x = rotated ? val : arg;
        var y = rotated ? arg : val;
        return getSegmentLength(px - x, py - y);
    };
    var createContinuousSeriesHitTesterCreator = function (makePath) { return function (points, rotated) {
        var fallbackHitTest = createCanvasAbusingHitTester(makePath, points, rotated);
        return function (target) {
            var minDistance = Number.MAX_VALUE;
            var minIndex = 0;
            var list = [];
            points.forEach(function (point, i) {
                var distance = getDistance(target, point, rotated);
                if (distance <= LINE_POINT_SIZE) {
                    list.push({ distance: distance, index: point.index });
                }
                if (distance < minDistance) {
                    minDistance = distance;
                    minIndex = i;
                }
            });
            // This is special case for continuous series - if no point is actually hit
            // then the closest point to the pointer position is picked.
            if (!list.length && fallbackHitTest(target)) {
                list.push({ index: points[minIndex].index, distance: minDistance });
            }
            return list.length ? { points: list } : null;
        };
    }; };
    var createPointsEnumeratingHitTesterCreator = function (hitTestPoint) { return function (points, rotated) { return function (target) {
        var list = [];
        points.forEach(function (point) {
            var status = hitTestPoint(target, point, rotated);
            if (status) {
                list.push({ index: point.index, distance: status.distance });
            }
        });
        return list.length ? { points: list } : null;
    }; }; };
    /** @internal */
    var createAreaHitTester = createContinuousSeriesHitTesterCreator(function (rotated) {
        var path = d3Shape.area();
        var hitArea = rotated ? dRotateArea : dArea;
        if (rotated) {
            path.x1(hitArea.x1());
            path.x0(hitArea.x0());
            path.y(hitArea.y());
        }
        else {
            path.x(hitArea.x());
            path.y1(hitArea.y1());
            path.y0(hitArea.y0());
        }
        return path;
    });
    /** @internal */
    var createLineHitTester = createContinuousSeriesHitTesterCreator(function (rotated) {
        var path = d3Shape.area();
        var hitLine = rotated ? dRotateLine : dLine;
        if (rotated) {
            var getX_1 = hitLine.x();
            path.y(hitLine.y());
            path.x0(function (point) { return getX_1(point) + LINE_TOLERANCE; });
            path.x1(function (point) { return getX_1(point) - LINE_TOLERANCE; });
        }
        else {
            var getY_1 = hitLine.y();
            path.x(hitLine.x());
            path.y1(function (point) { return getY_1(point) - LINE_TOLERANCE; });
            path.y0(function (point) { return getY_1(point) + LINE_TOLERANCE; });
        }
        return path;
    });
    /** @internal */
    var createSplineHitTester = createContinuousSeriesHitTesterCreator(function (rotated) {
        var path = d3Shape.area();
        var hitSpline = rotated ? dRotateSpline : dSpline;
        if (rotated) {
            var getX_2 = hitSpline.x();
            path.y(hitSpline.y());
            path.x1(function (point) { return getX_2(point) - LINE_TOLERANCE; });
            path.x0(function (point) { return getX_2(point) + LINE_TOLERANCE; });
        }
        else {
            var getY_2 = hitSpline.y();
            path.x(hitSpline.x());
            path.y1(function (point) { return getY_2(point) - LINE_TOLERANCE; });
            path.y0(function (point) { return getY_2(point) + LINE_TOLERANCE; });
        }
        path.curve(hitSpline.curve());
        return path;
    });
    var hitTestRect = function (dx, dy, halfX, halfY) { return (Math.abs(dx) <= halfX && Math.abs(dy) <= halfY ? {
        distance: getSegmentLength(dx, dy),
    } : null); };
    // Some kind of binary search can be used here as bars can be ordered along argument axis.
    /** @internal */
    var createBarHitTester = createPointsEnumeratingHitTesterCreator(function (_a, point, rotated) {
        var _b = __read(_a, 2), px = _b[0], py = _b[1];
        var _c = point, arg = _c.arg, val = _c.val, startVal = _c.startVal, barWidth = _c.barWidth, maxBarWidth = _c.maxBarWidth;
        var halfWidth = maxBarWidth * barWidth / 2;
        var halfHeight = Math.abs(val - startVal) / 2;
        var centerVal = (val + startVal) / 2;
        var xCenter = rotated ? centerVal : arg;
        var yCenter = rotated ? arg : centerVal;
        return hitTestRect(px - xCenter, py - yCenter, rotated ? halfHeight : halfWidth, rotated ? halfWidth : halfHeight);
    });
    /** @internal */
    var createScatterHitTester = createPointsEnumeratingHitTesterCreator(function (_a, obj, rotated) {
        var _b = __read(_a, 2), px = _b[0], py = _b[1];
        var point = obj.point;
        var distance = getDistance([px, py], obj, rotated);
        return distance <= point.size / 2 ? { distance: distance } : null;
    });
    var mapAngleTod3 = function (angle) {
        var ret = angle + Math.PI / 2;
        return ret >= 0 ? ret : ret + Math.PI * 2;
    };
    // Some kind of binary search can be used here as pies can be ordered along angle axis.
    /** @internal */
    var createPieHitTester = createPointsEnumeratingHitTesterCreator(function (_a, point) {
        var _b = __read(_a, 2), px = _b[0], py = _b[1];
        var _c = point, x = _c.arg, y = _c.val, innerRadius = _c.innerRadius, outerRadius = _c.outerRadius, startAngle = _c.startAngle, maxRadius = _c.maxRadius, endAngle = _c.endAngle;
        var inner = innerRadius * maxRadius;
        var outer = outerRadius * maxRadius;
        var rCenter = (inner + outer) / 2;
        var angleCenter = (startAngle + endAngle) / 2;
        var halfRadius = (outer - inner) / 2;
        var halfAngle = Math.abs(startAngle - endAngle) / 2;
        var dx = px - x;
        var dy = py - y;
        var r = getSegmentLength(dx, dy);
        var angle = mapAngleTod3(Math.atan2(dy, dx));
        // This is not a correct distance calculation but for now it will suffice.
        // For Pie series it would not be actually used.
        return hitTestRect(r - rCenter, angle - angleCenter, halfRadius, halfAngle);
    });
    var buildFilter = function (targets) {
        var result = {};
        targets.forEach(function (_a) {
            var series = _a.series, point = _a.point;
            (result[series] = result[series] || new Set()).add(point);
        });
        return result;
    };
    /** @internal */
    var changeSeriesState = function (seriesList, targets, state) {
        if (targets.length === 0) {
            return seriesList;
        }
        var filter = buildFilter(targets);
        var matches = 0;
        var result = seriesList.map(function (seriesItem) {
            var set = filter[seriesItem.name];
            if (!set) {
                return seriesItem;
            }
            matches += 1;
            var props = { state: state };
            if (set.size) {
                props.points = seriesItem.points.map(function (point) { return (set.has(point.index) ? __assign(__assign({}, point), { state: state }) : point); });
            }
            return __assign(__assign({}, seriesItem), props);
        });
        // This is to prevent false rerenders.
        return matches > 0 ? result : seriesList;
    };

    var getDefaultLegendItems = function (series) { return series.map(function (_a) {
        var text = _a.name, color = _a.color;
        return ({ text: text, color: color });
    }); };
    var getPieLegendItems = function (series) { return series[0]
        .points.map(function (_a) {
        var text = _a.argument, color = _a.color;
        return ({ text: text, color: color });
    }); };
    // The function supports special case when there is single Pie series.
    // There is no common way to tell if series is PieSeries -
    // checking `radius` props will suffice for now.
    var isSinglePieSeriesCase = function (series) { return (series.length === 1 && 'innerRadius' in series[0] && 'outerRadius' in series[0]); };
    /** @internal */
    var getLegendItems = function (series) { return ((isSinglePieSeriesCase(series) ? getPieLegendItems : getDefaultLegendItems)(series)); };

    var DISTANCE_THRESHOLD = 20;
    var compareHitTargets = function (t1, t2) {
        var distanceDelta = t1.distance - t2.distance;
        if (Math.abs(distanceDelta) <= DISTANCE_THRESHOLD) {
            var orderDelta = t2.order - t1.order;
            return orderDelta !== 0 ? orderDelta : distanceDelta;
        }
        return distanceDelta;
    };
    var buildEventHandler = function (seriesList, handlers) {
        var hitTesters = null;
        var createHitTesters = function () {
            var obj = {};
            seriesList.forEach(function (seriesItem) {
                obj[seriesItem.symbolName] = seriesItem
                    .createHitTester(seriesItem.points, seriesItem.rotated);
            });
            return obj;
        };
        return function (e) {
            var location = getEventCoords(e, getOffset(e.currentTarget));
            hitTesters = hitTesters || createHitTesters();
            var targets = [];
            seriesList.forEach(function (_a) {
                var series = _a.name, order = _a.index, symbolName = _a.symbolName;
                var status = hitTesters[symbolName](location);
                if (status) {
                    targets.push.apply(targets, __spreadArray([], __read(status.points.map(function (point) { return ({
                        series: series,
                        order: order,
                        point: point.index, distance: point.distance,
                    }); })), false));
                }
            });
            targets.sort(compareHitTargets);
            var arg = { location: location, targets: targets, event: e.nativeEvent };
            handlers.forEach(function (handler) { return handler(arg); });
        };
    };
    var buildLeaveEventHandler = function (handlers) { return function (e) {
        var location = getEventCoords(e, getOffset(e.currentTarget));
        var arg = { location: location, targets: [] };
        handlers.forEach(function (handler) { return handler(arg); });
    }; };
    // The result is of Map<string, Function> type.
    // Keys are DOM event names (https://developer.mozilla.org/en-US/docs/Web/Events).
    /** @internal */
    var buildEventHandlers = function (seriesList, _a) {
        var clickHandlers = _a.clickHandlers, pointerMoveHandlers = _a.pointerMoveHandlers;
        var handlers = {};
        if (!dxCore.hasWindow())
            return handlers;
        if (clickHandlers.length) {
            handlers.click = buildEventHandler(seriesList, clickHandlers);
        }
        if (pointerMoveHandlers.length) {
            var moveHandler = buildEventHandler(seriesList, pointerMoveHandlers);
            var leaveHandler = buildLeaveEventHandler(pointerMoveHandlers);
            if ('ontouchstart' in window) {
                handlers.touchstart = moveHandler;
            }
            else {
                handlers.mousemove = moveHandler;
                handlers.mouseleave = leaveHandler;
            }
        }
        return handlers;
    };

    /** @internal */
    var getProgress = function (_a) {
        var elapsed = _a.elapsed, total = _a.total;
        return Math.min(elapsed / total, 1);
    };
    /** @internal */
    var runAnimation = function (setAttributes, getNewPositions, easing, duration, delay) { return new Promise(function (resolve) {
        setTimeout(function () {
            var time = {
                start: Date.now(),
                total: duration,
                elapsed: 0,
            };
            var step = function () {
                time.elapsed = Date.now() - time.start;
                var progress = getProgress(time);
                setAttributes(getNewPositions(easing(progress)));
                if (progress < 1)
                    requestAnimationFrame(step);
            };
            resolve(requestAnimationFrame(step));
        }, delay);
    }); };
    /** @internal */
    var buildAnimation = function (easing, duration) { return function (startCoords, endCoords, processAnimation, setAttributes, delay) {
        if (delay === void 0) { delay = 0; }
        var animationID;
        var stop = function () {
            if (animationID) {
                cancelAnimationFrame(animationID);
                animationID = undefined;
            }
        };
        var run = function (start, end, delayValue) {
            animationID = runAnimation(setAttributes, processAnimation(start, end), easing, duration, delayValue).then(function (res) {
                animationID = res;
            });
        };
        run(startCoords, endCoords, delay);
        return {
            update: function (updatedStartCoords, updatedEndCoords, updatedDelay) {
                if (updatedDelay === void 0) { updatedDelay = 0; }
                stop();
                run(updatedStartCoords, updatedEndCoords, updatedDelay);
            },
            stop: stop,
        };
    }; };
    var lerp = function (a, b, t) { return a + t * (b - a); };
    /** @internal */
    var processPointAnimation = function (startCoords, endCoords) {
        return function (progress) {
            return {
                arg: lerp(startCoords.arg, endCoords.arg, progress),
                val: lerp(startCoords.val, endCoords.val, progress),
            };
        };
    };
    /** @internal */
    var processBarAnimation = function (startCoords, endCoords) {
        return function (progress) {
            return {
                arg: lerp(startCoords.arg, endCoords.arg, progress),
                val: lerp(startCoords.val, endCoords.val, progress),
                startVal: lerp(startCoords.startVal, endCoords.startVal, progress),
            };
        };
    };
    /** @internal */
    var processLineAnimation = function (_a, _b) {
        var coordinates = _a.coordinates;
        var endCoordinates = _b.coordinates;
        return function (progress) {
            return {
                coordinates: endCoordinates.map(function (coord, index) {
                    var startCurCoord = coordinates[index];
                    return __assign(__assign({}, coord), { arg: lerp(startCurCoord.arg, coord.arg, progress), val: lerp(startCurCoord.val, coord.val, progress) });
                }),
            };
        };
    };
    /** @internal */
    var processAreaAnimation = function (_a, _b) {
        var coordinates = _a.coordinates;
        var endCoordinates = _b.coordinates;
        return function (progress) {
            return {
                coordinates: endCoordinates.map(function (coord, index) {
                    var startCurCoord = coordinates[index];
                    return __assign(__assign({}, coord), { arg: lerp(startCurCoord.arg, coord.arg, progress), val: lerp(startCurCoord.val, coord.val, progress), startVal: lerp(startCurCoord.startVal, coord.startVal, progress) });
                }),
            };
        };
    };
    /** @internal */
    var processPieAnimation = function (start, end) {
        return function (progress) {
            return {
                innerRadius: lerp(start.innerRadius, end.innerRadius, progress),
                outerRadius: lerp(start.outerRadius, end.outerRadius, progress),
                startAngle: lerp(start.startAngle, end.startAngle, progress),
                endAngle: lerp(start.endAngle, end.endAngle, progress),
            };
        };
    };

    exports.ARGUMENT_DOMAIN = ARGUMENT_DOMAIN;
    exports.BAND = BAND;
    exports.BOTTOM = BOTTOM;
    exports.DIFFERENCE = DIFFERENCE;
    exports.END = END;
    exports.HORIZONTAL = HORIZONTAL;
    exports.HOVERED = HOVERED;
    exports.LEFT = LEFT;
    exports.LINEAR = LINEAR;
    exports.MIDDLE = MIDDLE;
    exports.RIGHT = RIGHT;
    exports.SELECTED = SELECTED;
    exports.START = START;
    exports.TOP = TOP;
    exports.VALUE_DOMAIN = VALUE_DOMAIN;
    exports.VERTICAL = VERTICAL;
    exports.addDomain = addDomain;
    exports.addSeries = addSeries;
    exports.adjustBarSize = adjustBarSize;
    exports.adjustLayout = adjustLayout;
    exports.attachEvents = attachEvents;
    exports.bBoxes = bBoxes;
    exports.buildAnimation = buildAnimation;
    exports.buildEventHandlers = buildEventHandlers;
    exports.buildScales = buildScales;
    exports.changeSeriesState = changeSeriesState;
    exports.createAreaHitTester = createAreaHitTester;
    exports.createBarHitTester = createBarHitTester;
    exports.createLineHitTester = createLineHitTester;
    exports.createPieHitTester = createPieHitTester;
    exports.createReference = createReference;
    exports.createScatterHitTester = createScatterHitTester;
    exports.createSplineHitTester = createSplineHitTester;
    exports.dArea = dArea;
    exports.dBar = dBar;
    exports.dLine = dLine;
    exports.dPie = dPie;
    exports.dRotateArea = dRotateArea;
    exports.dRotateLine = dRotateLine;
    exports.dRotateSpline = dRotateSpline;
    exports.dSpline = dSpline;
    exports.dSymbol = dSymbol;
    exports.defaultDomains = defaultDomains;
    exports.detachEvents = detachEvents;
    exports.easeOutCubic = easeOutCubic;
    exports.extendDomains = extendDomains;
    exports.findSeriesByName = findSeriesByName;
    exports.getAreaPointTransformer = getAreaPointTransformer;
    exports.getBarPointTransformer = getBarPointTransformer;
    exports.getDelay = getDelay;
    exports.getDeltaForTouches = getDeltaForTouches;
    exports.getEventCoords = getEventCoords;
    exports.getLegendItems = getLegendItems;
    exports.getLinePointTransformer = getLinePointTransformer;
    exports.getOffset = getOffset;
    exports.getParameters = getParameters;
    exports.getPathStart = getPathStart;
    exports.getPiePointTransformer = getPiePointTransformer;
    exports.getPieStart = getPieStart;
    exports.getPointStart = getPointStart;
    exports.getRanges = getRanges;
    exports.getRect = getRect$1;
    exports.getRotatedPosition = getRotatedPosition;
    exports.getScatterPointTransformer = getScatterPointTransformer;
    exports.getStackedDomains = getStackedDomains;
    exports.getStackedSeries = getStackedSeries;
    exports.getStartVal = getStartVal$1;
    exports.getTickCoordinates = getTickCoordinates;
    exports.getValueDomainName = getValueDomainName;
    exports.getViewport = getViewport;
    exports.getVisibility = getVisibility;
    exports.getWheelDelta = getWheelDelta;
    exports.getWidth = getWidth;
    exports.gridCoordinatesGetter = gridCoordinatesGetter;
    exports.growBounds = growBounds;
    exports.invertBoundsRange = invertBoundsRange;
    exports.isCoordinatesChanged = isCoordinatesChanged;
    exports.isHorizontal = isHorizontal;
    exports.isKeyPressed = isKeyPressed;
    exports.isMultiTouch = isMultiTouch;
    exports.isReadyToRenderSeries = isReadyToRenderSeries;
    exports.isScalesChanged = isScalesChanged;
    exports.isValidPosition = isValidPosition;
    exports.isValuesChanged = isValuesChanged;
    exports.makeScale = makeScale;
    exports.moveBounds = moveBounds;
    exports.processAreaAnimation = processAreaAnimation;
    exports.processBarAnimation = processBarAnimation;
    exports.processHandleTooltip = processHandleTooltip;
    exports.processLineAnimation = processLineAnimation;
    exports.processPieAnimation = processPieAnimation;
    exports.processPointAnimation = processPointAnimation;
    exports.processPointerMove = processPointerMove;
    exports.rangesEqual = rangesEqual;
    exports.scaleBand = scaleBand;
    exports.scaleBounds = scaleBounds;
    exports.scaleLinear = scaleLinear;
    exports.scaleSeriesPoints = scaleSeriesPoints;
    exports.setCursorType = setCursorType;
    exports.tickCoordinatesGetter = tickCoordinatesGetter;
    exports.updateDomainItems = updateDomainItems;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=dx-chart-core.umd.cjs.map
